//----------------------------------------------------------------------------------
// Fragment shader for the "Custom" filter (last in the catalog)
//----------------------------------------------------------------------------------
// Available uniforms:
//
// uniform float     iTime       : time in seconds
// uniform int       iFrame      : frame since the filter started running
// uniform vec3      iResolution : viewport resultion in .xy, horizontal crop in .z 
// uniform float     iParam[2]   : UI slider positions (from 0.0 to 1.0)
// uniform sampler2D iChannel0   : the webcam image
// uniform sampler2D iChannel1   : 256x256 grayscale random numbers
//----------------------------------------------------------------------------------

// SOURCE: https://www.shadertoy.com/view/wsfcDM
// With modifications by Jose Luis Garcia del Castillo (ParametricCamp)

#define ANIMATE 10.0
#define INV_ANIMATE_FREQ 0.05
#define RADIUS 1.3
#define FREQ 10.0
#define LENGTH 2.0
#define SOFTNESS 0.1
#define WEIRDNESS 0.1

#define ASPECT_AWARE

#define lofi(x,d) (floor((x)/(d))*(d))

float getChromaKey( inout vec3 col )
{
    float maxrb = max( col.r, col.b );
    float k = clamp( (col.g-maxrb)*10.0, 0.0, 1.0 );
    float dg = col.g; 
    col.g = min( col.g, maxrb*0.8 ); 
    col += dg - col.g;
    return k;
}

float hash( vec2 v ) {
  return fract( sin( dot( v, vec2( 89.44, 19.36 ) ) ) * 22189.22 );
}

float iHash( vec2 v, vec2 r ) {
  vec4 h = vec4(
    hash( vec2( floor( v * r + vec2( 0.0, 0.0 ) ) / r ) ),
    hash( vec2( floor( v * r + vec2( 0.0, 1.0 ) ) / r ) ),
    hash( vec2( floor( v * r + vec2( 1.0, 0.0 ) ) / r ) ),
    hash( vec2( floor( v * r + vec2( 1.0, 1.0 ) ) / r ) )
  );
  vec2 ip = vec2( smoothstep(
    vec2( 0.0 ),
    vec2( 1.0 ),
    mod( v * r, 1.0 ) )
  );
  return mix(
    mix( h.x, h.y, ip.y ),
    mix( h.z, h.w, ip.y ),
    ip.x
  );
}

float noise( vec2 v ) {
  float sum = 0.0;
  for( int i = 1; i < 7; i ++ ) {
    sum += iHash(
      v + vec2( i ),
      vec2( 2.0 * pow( 2.0, float( i ) ) ) ) / pow( 2.0, float( i )
    );
  }
  return sum;
}

// Memix boilerplate getuv function
vec2 getuv( in vec2 p ) { return vec2( 0.5+(p.x-0.5)*iResolution.z, 1.0-p.y ); }

// Chroma: (99,205,164)
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // vec2 uv = fragCoord / iResolution.xy;
    float u = fragCoord.x / iResolution.x;
    float v = 1 - fragCoord.y / iResolution.y;
    vec2 uv = vec2(u, v);

    vec3 pixelColor = texture(iChannel0, uv).xyz;

    float k = getChromaKey( pixelColor );

    if (k > iParam[0]) {
        // Explosion effect
        #ifdef ASPECT_AWARE
        vec2 uv = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.xy;
        #else
        vec2 uv = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.y;
        #endif
        vec2 puv = vec2(
            WEIRDNESS * length( uv ) + ANIMATE * lofi( iTime, INV_ANIMATE_FREQ ),
            FREQ * atan( uv.y, uv.x )
        );
        float value = noise( puv );
        value = length( uv ) - RADIUS - LENGTH * ( value - 0.5 );
        value = smoothstep( -SOFTNESS, SOFTNESS, value );

        // vec4 tex = texture( iChannel0, getuv( fragCoord.xy / iResolution.xy ) );
        vec3 color = mix( vec3(0.0), vec3( 1.0, 0.0, 1.0 ), value );
        fragColor = vec4( color, 1.0 );
    }
    else {
        fragColor = vec4(pixelColor, 1.0);
    }
    
}



// void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
// #ifdef ASPECT_AWARE
//   vec2 uv = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.xy;
// #else
//   vec2 uv = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.y;
// #endif
//   vec2 puv = vec2(
//     WEIRDNESS * length( uv ) + ANIMATE * lofi( iTime, INV_ANIMATE_FREQ ),
//     FREQ * atan( uv.y, uv.x )
//   );
//   float value = noise( puv );
//   value = length( uv ) - RADIUS - LENGTH * ( value - 0.5 );
//   value = smoothstep( -SOFTNESS, SOFTNESS, value );

//   vec4 tex = texture( iChannel0, getuv( fragCoord.xy / iResolution.xy ) );
//   vec3 color = mix( tex.xyz, vec3( 1.0 ), value );
//   fragColor = vec4( color, 1.0 );
// }
